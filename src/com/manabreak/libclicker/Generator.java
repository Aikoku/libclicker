package com.manabreak.libclicker;

import com.manabreak.libclicker.Modifier.GeneratorModifier;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Random;

/**
 *
 * @author Harri
 */
public class Generator extends Item
{
    public interface Callback
    {
        void onProcessed();
    }
    
    /**
     * World this generator currently belongs to
     */
    private World m_world = null;
    
    /**
     * Callback for extended functionality
     */
    private Callback m_callback = null;
    
    /**
     * Currency this generator should generate
     */
    private Currency m_currency;
    
    /**
     * How many times this generator has been processed
     */
    private long m_timesProcessed = 0;
    
    /**
     * Base amount of resources this generator generates
     */
    private BigInteger m_baseAmount;
    
    /**
     * Multiplier used to increase the amount of resources generated
     * when this generator is upgraded
     */
    private double m_amountMultiplier;
    
    /**
     * Probability for this generator to "work"
     */
    private double m_probability;
    
    /**
     * Should this generator use probability?
     */
    private boolean m_useProbability;
    
    /**
     * RNG for probability
     */
    private Random m_random;
    
    /**
     * Should we take remainders into consideration?
     */
    private boolean m_useRemainder;
    
    /**
     * Remainder of the last processing cycle
     */
    private double m_remainder;
    
    /**
     * Cooldown time between processing cycles.
     */
    private double m_cooldown;
    
    /**
     * List of active modifiers attached to this generator
     */
    private ArrayList<GeneratorModifier> m_modifiers = new ArrayList<>();
    
    /**
     * Builder class for creating new generators
     */
    public static class Builder
    {
        private final World m_world;
        private String m_name = "Nameless generator";
        private Callback m_onProcessed = null;
        private Currency m_currency = null;
        private BigInteger m_baseAmount = BigInteger.ONE;
        private double m_amountMultiplier = 1.1;
        private long m_maxLevel = Long.MAX_VALUE;
        private BigInteger m_basePrice = BigInteger.ONE;
        private double m_priceMultiplier = 1.1;
        private double m_probability = 1.0;
        private boolean m_probabilitySet = false;
        private boolean m_useRemainder = true;
        private double m_cooldown = 0.0;
        /**
         * Creates a new generator builder
         * @param world World to build the generator into
         */
        public Builder(World world)
        {
            m_world = world;
        }
        
        public Builder cooldown(double cooldown)
        {
            m_cooldown = cooldown;
            return this;
        }
        
        /**
         * Store remainder of resources and add an extra
         * when the remainder "overflows"
         * @return This builder for chaining
         */
        public Builder useRemainder()
        {
            m_useRemainder = true;
            return this;
        }
        
        /**
         * Discard remainder of resources when generating.
         * @return This builder for chaining
         */
        public Builder discardRemainder()
        {
            m_useRemainder = false;
            return this;
        }
        
        /**
         * Sets the name for the generator
         * @param name Name for the generator
         * @return This builder for chaining
         */
        public Builder name(String name)
        {
            m_name = name;
            return this;
        }
        
        /**
         * Sets the multiplier for resource generation. This multiplier
         * is used in the formula (amount) = (base amount) * (multiplier) ^ (level)
         * @param multiplier Amount generation multiplier per level
         * @return This builder for chaining
         */
        public Builder multiplier(double multiplier)
        {
            m_amountMultiplier = multiplier;
            return this;
        }
        
        /**
         * Sets the maximum allowed level for this generator. The max level must
         * be greated than zero.
         * @param maxLevel Maximum allowed level for this generator
         * @return This builder for chaining
         */
        public Builder maxLevel(long maxLevel)
        {
            if(maxLevel <= 0) throw new IllegalArgumentException("Max level must be greater than 0");
            m_maxLevel = maxLevel;
            return this;
        }
        
        /**
         * Sets the base amount of resources generated by this generator.
         * This is the amount the generator generates at level 1 and is used
         * as the base for the higher levels.
         * @param amount Base amount of resources generated at level 1
         * @return This builder for chaining
         */
        public Builder baseAmount(BigInteger amount)
        {
            if(amount == null) throw new IllegalArgumentException("Base amount cannot be null");
            m_baseAmount = amount;
            return this;
        }
        
        /**
         * Sets the base amount of resources generated by this generator.
         * This is the amount the generator generates at level 1 and is used
         * as the base for the higher levels.
         * @param amount Base amount of resources generated at level 1
         * @return This builder for chaining
         */
        public Builder baseAmount(long amount)
        {
            m_baseAmount = new BigInteger("" + amount);
            return this;
        }
        
        /**
         * Sets the base amount of resources generated by this generator.
         * This is the amount the generator generates at level 1 and is used
         * as the base for the higher levels.
         * @param amount Base amount of resources generated at level 1
         * @return This builder for chaining
         */
        public Builder baseAmount(int amount)
        {
            m_baseAmount = new BigInteger("" + amount);
            return this;
        }
        
        /**
         * Sets the currency that should be generated by the generator.
         * @param c Currency to generate
         * @return This builder for chaining
         * @throws IllegalArgumentException Thrown if the currency is null
         */
        public Builder generate(Currency c) throws IllegalArgumentException
        {
            if(c == null) throw new IllegalArgumentException("Currency cannot be null");
            m_currency = c;
            return this;
        }
        
        /**
         * Sets a callback for the generator to be called when the generator
         * has finished its processing cycle (i.e. has generated something).
         * @param callback Callback to call after generating something
         * @return This builder for chaining
         */
        public Builder callback(Callback callback)
        {
            m_onProcessed = callback;
            return this;
        }
        
        public Builder price(BigInteger price)
        {
            m_basePrice = price;
            return this;
        }
        
        public Builder price(long price)
        {
            m_basePrice = new BigInteger("" + price);
            return this;
        }
        
        public Builder price(int price)
        {
            m_basePrice = new BigInteger("" + price);
            return this;
        }
        
        public Builder priceMultiplier(double multiplier)
        {
            m_priceMultiplier = multiplier;
            return this;
        }
        
        /**
         * Set a probability for this generator to "work" when it's processed
         * @param probability Probability percentage (between 0.0 and 1.0)
         * @return This builder for chaining
         */
        public Builder probability(double probability)
        {
            if(probability < 0 || probability > 1.0) throw new IllegalArgumentException("Probability should be between 0.0 and 1.0");
            m_probability = probability;
            m_probabilitySet = true;
            return this;
        }
        
        /**
         * Constructs the generator based on the given parameters
         * @return The generator
         */
        public Generator build()
        {
            Generator g = new Generator(m_world, m_name);
            g.m_callback = m_onProcessed;
            g.m_currency = m_currency;
            g.m_amountMultiplier = m_amountMultiplier;
            g.m_baseAmount = m_baseAmount;
            g.m_maxItemLevel = m_maxLevel;
            g.m_basePrice = m_basePrice;
            g.m_priceMultiplier = m_priceMultiplier;
            g.m_probability = m_probability;
            g.m_useProbability = m_probabilitySet;
            g.m_random = new Random();
            g.m_random.setSeed(g.hashCode());
            g.m_useRemainder = m_useRemainder;
            g.m_cooldown = m_cooldown;
            return g;
        }
    }
    
    /**
     * Constructs a new generator
     */
    private Generator(World world)
    {
        super(world);
    }
    
    /**
     * Constructs a new generator
     * @param name Name of this generator
     */
    private Generator(World world, String name)
    {
        super(world, name);
    }
    
    /**
     * Called when this generator is added to the world
     */
    void onAdd(World world)
    {
        if(m_world == null) m_world = world;
    }
    
    /**
     * Called when this generator is removed from the world
     */
    void onRemove(World world)
    {
        m_world = null;
    }
    
    /**
     * Removes this generator from the world
     */
    void remove()
    {
        m_world.removeGenerator(this);
        m_world = null;
    }
    
    /**
     * Retrieves the world this generator belongs to
     * @return 
     */
    World getWorld()
    {
        return m_world;
    }

    /**
     * Upgrades this generator by one level
     */
    public void upgrade()
    {
        if(m_itemLevel < m_maxItemLevel)
        {
            m_itemLevel++;
        }
    }
    
    /**
     * Downgrades this generator by one level
     */
    public void downgrade()
    {
        if(m_itemLevel > 0)
        {
            m_itemLevel--;
        }
    }
    
    /**
     * Retrieves the amount this generator currently is generating per
     * processing cycle
     * @return Amount of resources generated by this generator
     */
    public BigInteger getGeneratedAmount()
    {
        if(m_itemLevel == 0) return BigInteger.ZERO;
        
        BigDecimal tmp = new BigDecimal(m_baseAmount);
        tmp = tmp.multiply(new BigDecimal(Math.pow(m_amountMultiplier, m_itemLevel - 1)));
        if(m_useRemainder)
        {
            double tmpRem = tmp.remainder(BigDecimal.ONE).doubleValue();
            m_remainder += tmpRem;
            if(m_remainder >= 0.999)
            {
                m_remainder -= 1.0;
                tmp = tmp.add(new BigDecimal(1));
            }
        }
        
        tmp = processModifiers(tmp);
        
        return tmp.toBigInteger();
    }
    
    private BigDecimal processModifiers(BigDecimal val)
    {
        if(m_modifiers.size() == 0) return val;
        
        for(GeneratorModifier m : m_modifiers)
        {
            double d = m.getMultiplier();
            if(d != 1.0)
            {
                val = val.multiply(new BigDecimal(d));
            }
        }
        
        return val;
    }
    
    /**
     * Determines if this generator should generate anything based on its
     * properties such as item level and probability.
     * 
     * @return True if should work, false otherwise
     */
    private boolean isWorking()
    {
        if(m_itemLevel > 0)
        {
            if(!m_useProbability || m_random.nextDouble() < m_probability) return true;
        }
        return false;
    }
    
    /**
     * Processes this generator, generating resources as per the rules
     * of this generator.
     */
    public void process()
    {
        if(isWorking())
        {
            m_currency.add(getGeneratedAmount());   
            m_timesProcessed++;
            if(m_callback != null) m_callback.onProcessed();
        }
    }
    
    /**
     * Retrieves the number of times this generator has done its processing
     * @return Number of times processed
     */
    public long getTimesProcessed()
    {
        return m_timesProcessed;
    }
    
    void attachModifier(GeneratorModifier modifier)
    {
        if(modifier != null && !m_modifiers.contains(modifier))
        {
            m_modifiers.add(modifier);
        }
    }
    
    void detachModifier(GeneratorModifier modifier)
    {
        if(modifier != null)
        {
            m_modifiers.remove(modifier);
        }
    }
}
